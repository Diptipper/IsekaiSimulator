<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Isekai Engine Documentation</title>
<style>
    body {
        font-family: sans-serif;
        line-height: 1.6;
        color: #202122;
        background-color: #ffffff;
        max-width: 960px;
        margin: 0 auto;
        padding: 20px;
    }
    h1 {
        font-family: 'Linux Libertine', 'Georgia', serif;
        border-bottom: 1px solid #a2a9b1;
        padding-bottom: 0.2em;
        font-size: 1.8em;
    }
    h2 {
        font-family: 'Linux Libertine', 'Georgia', serif;
        border-bottom: 1px solid #a2a9b1;
        padding-bottom: 0.2em;
        margin-top: 1.5em;
        font-size: 1.5em;
    }
    h3 {
        font-weight: bold;
        margin-top: 1.2em;
        font-size: 1.2em;
    }
    h4 {
        font-weight: bold;
        font-size: 1.0em;
        margin-bottom: 0.5em;
    }
    .toc {
        background-color: #f8f9fa;
        border: 1px solid #a2a9b1;
        display: inline-block;
        padding: 10px 20px;
        margin-bottom: 20px;
    }
    .toc h3 {
        margin-top: 0;
        text-align: center;
        font-size: 1em;
    }
    .toc ul {
        list-style-type: none;
        padding-left: 0;
    }
    .toc ul ul {
        padding-left: 20px;
    }
    a {
        text-decoration: none;
        color: #0645ad;
    }
    a:hover {
        text-decoration: underline;
    }
    pre {
        background-color: #f8f9fa;
        border: 1px solid #eaecf0;
        padding: 10px;
        overflow-x: auto;
        font-family: monospace;
        font-size: 0.9em;
    }
    code {
        background-color: #f8f9fa;
        border: 1px solid #eaecf0;
        padding: 2px 4px;
        font-family: monospace;
        border-radius: 2px;
    }
    table {
        border-collapse: collapse;
        margin: 1em 0;
        font-size: 0.9em;
    }
    th, td {
        border: 1px solid #a2a9b1;
        padding: 0.4em 0.8em;
        text-align: left;
    }
    th {
        background-color: #eaecf0;
        font-weight: bold;
    }
    .note {
        font-size: 0.9em;
        color: #555;
        font-style: italic;
        margin-top: 5px;
    }
</style>
</head>
<body>

<h1>Isekai Engine Documentation</h1>

<p>The <strong>Isekai Engine</strong> is a Javascript-based framework designed for creating text-based RPGs with visual novel elements. This documentation outlines the data structures, dialogue systems, scene management, and interaction logic required to build content for the engine.</p>

<div class="toc">
    <h3>Contents</h3>
    <ul>
        <li><a href="#intro">1 Introduction</a>
            <ul>
                <li><a href="#items">1.1 Item Definitions</a></li>
                <li><a href="#state">1.2 Global State</a></li>
                <li><a href="#skills">1.3 Classes and Skills</a></li>
                <li><a href="#enemy">1.4 Enemy Objects</a></li>
            </ul>
        </li>
        <li><a href="#dialogue">2 Dialogue System</a>
            <ul>
                <li><a href="#dialogue-struct">2.1 Structure</a></li>
                <li><a href="#effects">2.2 Special Effects</a></li>
                <li><a href="#interpolation">2.3 Variable Interpolation</a></li>
            </ul>
        </li>
        <li><a href="#scene">3 Scene Tree</a>
            <ul>
                <li><a href="#nodes">3.1 Node Types</a></li>
            </ul>
        </li>
        <li><a href="#interaction">4 Interaction Registry</a>
            <ul>
                <li><a href="#rules">4.1 Rule Objects</a></li>
                <li><a href="#logic">4.2 Execution Logic</a></li>
                <li><a href="#examples">4.3 Examples</a></li>
            </ul>
        </li>
    </ul>
</div>

<h2 id="intro">1. Introduction</h2>
<p>Understanding the basic data structures is essential for defining the game world.</p>

<h3 id="items">1.1 Item Definitions</h3>
<p>Items are stored in a dictionary called <code>ITEM_DEFINITIONS</code>. Developers append new items using <code>Object.assign</code>.</p>
<pre>Object.assign(ITEM_DEFINITIONS, {
    "Item name": {
        description: "This is the flavor text for this item",
        is_weapon: false,
        is_armor_body: false,
        is_armor_leggings: false,
        bonus_hp: 0,
        bonus_skills: new Skills(0,0,0,0),
    },
});</pre>
<p class="note"><strong>Note:</strong> An item should not be defined as both a weapon and armor simultaneously.</p>

<h3 id="state">1.2 Global State</h3>
<p>The <code>GLOBAL_STATE</code> object tracks game progress via "flags" (quest status, player name, choices). These must be initialized before use.</p>
<pre>Object.assign(GLOBAL_STATE.variables, {
    "demonKingTalked": false,
    "demonKingDefeated": false,
    "questCompleted": false,
});</pre>

<h3 id="skills">1.3 Classes and Skills</h3>
<p>There are currently four primary skills: <strong>Attack, Defense, Healing,</strong> and <strong>Agility</strong>.</p>
<ul>
    <li><strong>Attack & Defense:</strong> Used to calculate damage.
    <br><code>Damage = max(0, attacker.atk - defender.def)</code></li>
    <li><strong>Healing:</strong> Determines health regeneration outside of combat.</li>
    <li><strong>Agility:</strong> Determines hit chance based on the difference (ΔL) between attacker and defender agility.</li>
</ul>

<p><strong>Hit Chance Formula:</strong></p>
<pre>
ΔL = attacker.agi - defender.agi

If ΔL < 0: Chance = 2 / (4 - ΔL)
If ΔL ≥ 0: Chance = (1 + tanh(ΔL / 2)) / 2
</pre>

<table>
    <caption>Agility Difference Table</caption>
    <tr><th>ΔL</th><th>Hit Probability</th></tr>
    <tr><td>-5</td><td>0.22222</td></tr>
    <tr><td>-4</td><td>0.25000</td></tr>
    <tr><td>-3</td><td>0.28571</td></tr>
    <tr><td>-2</td><td>0.33333</td></tr>
    <tr><td>-1</td><td>0.40000</td></tr>
    <tr><td>0</td><td>0.50000</td></tr>
    <tr><td>+1</td><td>0.73105</td></tr>
    <tr><td>+2</td><td>0.88079</td></tr>
    <tr><td>+3</td><td>0.95257</td></tr>
    <tr><td>+4</td><td>0.98201</td></tr>
    <tr><td>+5</td><td>0.99330</td></tr>
</table>

<h3 id="enemy">1.4 Enemy Objects</h3>
<p>Enemies are instantiated using the <code>Enemy</code> class.</p>
<pre>const copperSpider = new Enemy(
    "Copper spider",            // Name
    10,                         // Max HP
    { "Copper spider legs": 1 },// Loot table {item: chance}
    new Skills(4, 2, 0, 1)      // Atk, Def, Regen, Agi
);</pre>

<h2 id="dialogue">2. Dialogue System</h2>

<h3 id="dialogue-struct">2.1 Structure</h3>
<p>Dialogue scenes are dictionaries defining backgrounds, speakers (sprites/positions), and a data array of conversation entries.</p>
<pre>{
    "background": "town_square.png",
    "speakers": {
        "Merchant": ["merchant.png", "(50%,0%)"]
    },
    "data": [
        ["dialogue", "Merchant", "Hello there!", ["Merchant:fade in"]],
        ["question", "Merchant", "Buy something?", [], {
            "Yes": true,
            "No": false
        }]
    ]
}</pre>

<h3 id="effects">2.2 Special Effects</h3>
<p>Effects are strings in the format <code>"target:effect:parameters"</code>. Available effects include:</p>
<ul>
    <li><code>fade in</code> / <code>fade out</code></li>
    <li><code>shake</code> (Use "Scene:shake" for screen shake)</li>
    <li><code>show</code> / <code>hide</code></li>
    <li><code>move:(x,y)</code></li>
    <li><code>scale:number</code></li>
    <li><code>change_sprite:filename.png</code></li>
</ul>

<h3 id="interpolation">2.3 Variable Interpolation</h3>
<p>Variables from <code>GLOBAL_STATE</code> can be injected into text using curly braces.</p>
<pre>["dialogue", "Guard", "So your name is {player name}.", []]</pre>

<h2 id="scene">3. Scene Tree</h2>
<p>The game world is structured as a nested dictionary (Graph/Tree). Each node key follows the format:</p>
<code>"node_type:node_name:Selection Text:bg_image.png; interaction(optional)"</code>



<h3 id="nodes">3.1 Node Types</h3>
<table>
    <tr>
        <th>Type</th>
        <th>Description</th>
        <th>Data Format</th>
    </tr>
    <tr>
        <td><strong>scene</strong></td>
        <td>Navigates to a sub-tree (nested dictionary).</td>
        <td><code>{ ...sub-nodes... }</code></td>
    </tr>
    <tr>
        <td><strong>return</strong></td>
        <td>Goes back to the previous node.</td>
        <td><code>{}</code></td>
    </tr>
    <tr>
        <td><strong>harvest</strong></td>
        <td>Triggers a timed gathering event.</td>
        <td><code>[time_ms, "Text", {item: chance}]</code></td>
    </tr>
    <tr>
        <td><strong>craft</strong></td>
        <td>Converts input items to output items.</td>
        <td><code>[time_ms, "Text", {"input:A": 1, "output:B": 1}]</code></td>
    </tr>
    <tr>
        <td><strong>fight</strong></td>
        <td>Initiates combat with an enemy from a weighted pool.</td>
        <td><code>[time_ms, "Text", {EnemyName: [weight, EnemyObj]}]</code></td>
    </tr>
    <tr>
        <td><strong>dungeon</strong></td>
        <td>A sequence of fights and interactions.</td>
        <td>Array of fight entries or interaction strings.</td>
    </tr>
</table>

<h2 id="interaction">4. Interaction Registry</h2>
<p>The <code>INTERACTION_REGISTRY</code> acts as a conditional decision tree. It maps an interaction ID to a list of rules, evaluating them top-to-bottom until a condition is met.</p>



<h3 id="rules">4.1 Rule Objects</h3>
<p>Each rule contains a <strong>Condition</strong> and <strong>Data</strong>.</p>
<h4>Conditions</h4>
<ul>
    <li><strong>Default:</strong> <code>condition: "default"</code> (Always runs if reached).</li>
    <li><strong>Item Check:</strong> <code>{ type: "item", id: "item_name", op: ">=", val: 1 }</code></li>
    <li><strong>Variable Check:</strong> <code>{ var: "var_name", op: "==", val: true }</code></li>
    <li><strong>Random:</strong> <code>{ var: "rand:uniform", op: "<", val: 0.3 }</code> (e.g., 30% chance).</li>
</ul>

<h4>Data</h4>
<p>If the condition passes, the <code>data</code> block executes. Common properties:</p>
<ul>
    <li><code>log_only</code>: Prints text and stops immediately.</li>
    <li><code>binding</code>: Binds the result of the next dialogue choice to a variable.</li>
    <li><code>dialogue</code>: Starts a conversation.</li>
    <li><code>on_finish</code>: Logic to run after dialogue ends.</li>
</ul>

<h3 id="logic">4.2 Execution Logic (on_finish)</h3>
<p>The <code>on_finish</code> block handles post-dialogue logic.</p>
<ul>
    <li><strong>Linear:</strong> A simple list of <code>actions</code> (reward, consume, set_state, goto).</li>
    <li><strong>Boolean:</strong> <code>if_true</code> / <code>if_false</code> branching based on a variable.</li>
    <li><strong>Switch Case:</strong> Checks a variable against multiple values to trigger specific dialogue/actions.</li>
</ul>

<h3 id="examples">4.3 Examples</h3>

<h4>Example 1: Simple Sign (Log Only)</h4>
<p>Use case: Clicking a background object that requires no logic or complex dialogue.</p>
<pre>
"sign_town_entrance": [
    {
        condition: "default",
        data: {
            log_only: "The sign reads: 'Welcome to Riverwood'."
        }
    }
]
</pre>

<h4>Example 2: A Treasure Chest (Item Logic)</h4>
<p>Use case: A chest that checks if it's already opened, checks if you have a key, or tells you it's locked.</p>
<pre>
"dungeon_chest": [
    {
        comment: "Priority 1: Check if already looted (Variable Check)",
        condition: [{ var: "chest_dungeon_1_open", op: "==", val: true }],
        data: { log_only: "The chest is empty." }
    },
    {
        comment: "Priority 2: Check if player has the key (Item Check)",
        condition: [{ type: "item", id: "skeleton_key", op: ">=", val: 1 }],
        data: {
            dialogue: openChestDialogueData,
            on_finish: {
                actions: [
                    { type: "consume", item: "skeleton_key", count: 1 }, // Remove key
                    { type: "set_state", key: "chest_dungeon_1_open", val: true }, // Mark open
                    { type: "reward", item: "gold_coin", count: 50 }, // Give reward
                    { type: "log", text: "You used the key and found 50 gold!" }
                ]
            }
        }
    },
    {
        comment: "Priority 3: Default (Locked)",
        condition: "default",
        data: { log_only: "It's locked. You need a Skeleton Key." }
    }
]
</pre>

<h4>Example 3: Random Encounter (RNG Logic)</h4>
<p>Use case: 30% chance to find an item, 70% nothing happens.</p>
<pre>
"search_bush": [
    {
        comment: "30% Chance (Random value < 0.3)",
        condition: [{ var: "rand:uniform", op: "<", val: 0.3 }],
        data: {
            on_finish: {
                actions: [
                    { type: "reward", item: "healing_herb", count: 1 },
                    { type: "log", text: "You found a medicinal herb!" }
                ]
            }
        }
    },
    {
        comment: "Remaining 70%",
        condition: "default",
        data: { log_only: "You search the bush but find nothing." }
    }
]
</pre>

<h4>Example 4: Complex NPC Interaction (Switch Case)</h4>
<p>Use case: An NPC reacts differently based on your reputation ('hero', 'villain', or 'neutral'). This utilizes the new switch_case logic to branch into different dialogues.</p>
<pre>
"npc_guard": [
    {
        condition: "default",
        data: {
            dialogue: guardGreetingData, // Initial "Halt!"
            on_finish: {
                check_var: "player_reputation", // Variable to switch on
                switch_case: {
                    "hero": {
                        dialogue: guardSaluteData, // Dialogue for hero
                        actions: [{ type: "log", text: "The guard salutes you." }]
                    },
                    "villain": {
                        dialogue: guardAttackData, // Dialogue for villain
                        actions: [{ type: "set_state", key: "combat_mode", val: true }]
                    },
                    "default": {
                        dialogue: GuardShrugData, // Fallback dialogue
                        actions: [{ type: "log", text: "The guard ignores you." }]
                    }
                }
            }
        }
    }
]
</pre>

<h4>Example 5: Navigation (Goto)</h4>
<p>Use case: Moving to another map node/scene.</p>
<pre>
"door_to_basement": [
    {
        condition: "default",
        data: {
            dialogue: "enter_door_sound",
            on_finish: {
                actions: [
                    { type: "goto", target: "basement_node_id" } 
                ]
            }
        }
    }
]
</pre>

<h4>Example 6: The Gatekeeper's Riddle</h4>
<p>Use Case: An ancient statue asks a question. You must choose the correct element ("Fire") to proceed.</p>
<pre>
"ancient_statue_riddle": [
    {
        condition: "default",
        data: {
            // 1. BINDING: Tell the engine to store the dialogue choice in "riddle_answer"
            binding: "riddle_answer",

            // 2. DIALOGUE: This ID implies a conversation with choices
            dialogue: statueRiddleDialogueData, 

            // 3. ON FINISH: Check the variable we just bound
            on_finish: {
                check_var: "riddle_answer", 

                // React based on what the player clicked
                switch_case: {
                    "Fire": {
                        dialogue: statueSuccessData,
                        actions: [
                            { type: "log", text: "The statue eyes glow red. The door opens." },
                            { type: "set_state", key: "temple_door_open", val: true }
                        ]
                    },
                    "Water": {
                        dialogue: statueFailWetData,
                        actions: [
                            { type: "log", text: "Water sprays from the statue!" },
                        ]
                    },
                    "default": {
                        dialogue: statueConfusedData,
                        actions: [{ type: "log", text: "The statue remains silent." }]
                    }
                }
            }
        }
    }
]
</pre>

</body>
</html>