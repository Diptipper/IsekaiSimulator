


========================================
   Chapter 1: Introduction
========================================

Here we will explain how to make your own text-based RPG with this Isekai Engine.
Let us first understand some basic data structure.

1. <ITEM_DEFINITIONS>
----------------------------------------
This is a dictionary that contains relevant items in the game.
You are to append this dictionary when you add more game components.
To do so, use the following command:

	Object.assign(ITEM_DEFINITIONS, {
	    "Item name": {
	    	description: "This is the flavor text for this item"
	    	is_weapon: false,
	    	is_armor_body: false,
	    	is_armor_leggings: false,
	    	bonus_hp: 0,
	    	bonus_skills:new Skills(0,0,0,0),
	    },
	});

Don't make an item both a weapon and an armor at the same time.
I will explain about Skills later.

2. <GLOBAL_STATE>
----------------------------------------
This contains "flags" for quests and other stuff, like player name, choices, etc.
You have to declare these state variables before using them in the quest:

	Object.assign(GLOBAL_STATE.variables, {
	    "demonKingTalked": false,
	    "demonKingDefeated": false,
	    "questCompleted": false,
	});

I will explain how to use these variables later,

3. <INTERACTION_REGISTRY>
----------------------------------------
This object dictates all interactions in the game. I will devote a separate chapter for this.

4. Classes
----------------------------------------

4.1 Skills

Currently there are 4 skills: Attack, Defense, Healing, and Agility.

Attack and Defense determine the damage being dealt/received.
The current formula (might change later) is

	Damage dealt = max(0, attacker's attack - defender's defense )

Healing is for health regeneration outside of the combat.
It has no use during the combat.

Agility is used to compute the chance of landing a hit on the opponent.
The current formula (might change later) is

	Landing chance = {
		if ŒîL<0: 2/(4-ŒîL),
		if ŒîL‚â•0: (1+tanh(ŒîL/2))/2
	}
	ŒîL = attacker's agility - defender's agility

	ŒîL 	Landing chance
	-5	0.22222
	-4	0.25
	-3	0.28571
	-2	0.33333
	-1	0.4
	 0	0.5
	+1	0.73105
	+2	0.88079
	+3	0.95257
	+4	0.98201
	+5	0.9933

4.2 Enemy
An enemy object can be defined by the command

	new Enemy(name, hp, loots, skills)

where <name> is the display name of the enemy,
<hp> is the max health,
<loots> is a dictionary { <item name>: <drop chance> },
and <skills> is the Skills object given above.

For example,

const copperSpider = new Enemy(
							"Copper spider", 10,
							{ "Copper spider legs": 1 },
							new Skills(4,2,0,1)
							);

creates a spider enemy with health 10,
dropping the legs 100% of the time,
and with atk 4, def 2, regen 0, and agi 1


========================================
   Chapter 2: Dialogue
========================================

Dialogue is given by a dictionary of the following format:

	{
		"background": <bg_image.png>,
		"speakers": { <speaker_name>: [ <sprite.png>, <initial_position> ] },
		"data": [
			[<entry_type>,<speaker_name>,<dialogue_text>,[<special_effect>],<choices(optional)>]
		]
	}

<entry_type> can be either "dialogue" or "question"
<choices> is used when <entry_type> is "question".
the format is {<choice>:<stored_value>}.

And <special_effect> is a string of the format "<target>:<effect>:<parameters(optional)>".
Special effect can be one of the following:
	- "<target>:fade in"
	- "<target>:fade out"
	- "<target>:shake"
	- "<target>:show"
	- "<target>:hide"
	- "<target>:move:<new_position>"
	- "<target>:scale:<new_scale>"
	- "<target>:change_sprite:<new_sprite.png>"
Note: you can use "Scene:shake" to shake the whole screen.

You can display the variable in the Global state by writing the variable name within a curly bracket {}. For example, let's say you have

	Object.assign(GLOBAL_STATE.variables, {"player name": "Henry",});

Then the dialogue

	["dialogue","Guard","So your name is {player name}.", ["Guard:shake"]]

will show the Guard saying "So your name is Henry." with a shaking sprite.
I will explain more about variables in Chapter 4.


Here are some of the example dialogues.

	{
	    "background": "town_square.png",
	    "speakers": {
	        "Merchant": ["merchant.png", "(50%,0%)"]
	    },
	    "data": [
	        ["dialogue","Merchant","Hello there! I'm running low on supplies.",
	        ["Merchant:fade in"]],
	        ["question","Merchant","Could you go to the woods and find me 3 Emerald roots?", [] ,{
	            "Sure thing": true,
	            "Not now": false
	        }]
	    ]
	};

	{
	    "background": "tavern.png",
	    "speakers": {
	        "Lady V": ["seductress.png", "(50%,0%)"]
	    },
	    "data": [
	        ["dialogue", "Lady V", "Wise choice, handsome.",
	        ["Lady V:change_sprite:seductress_happy.png","Lady V:fade in","Lady V:scale:1.2"]],
	        ["dialogue", "Lady V", "Follow me. It's not far.",
	        ["Lady V:fade out","Lady V:scale:1.0"]]
	    ]
	};


	{
		"background": "ruins_garden.png",
	    "speakers": { "Elara": ["elara.png", "(50%,0%)"] },
	    "data": [
	        ["dialogue","Elara","...Is it dead? Is the monster gone?",["Elara:fade in", "Elara:shake"]],
	        ["dialogue","You","It's over. You're safe now.", []],
	        ["dialogue","Elara","My hero... I thought I would never see the sky again.",["Elara:move:(50%,0%)"]],
	        ["question","Elara","Why... why did you come for me?", [] ,{
	            "The Mayor sent me": "it was merely duty",
	            "I couldn't let such beauty fade": "your heart led you here" }
	        ],
	        ["dialogue","Elara","I see... {elara feeling}.", ["Elara:shake"]],
	        ["dialogue","Elara","Let's go home. I will never forget this.", ["Elara:fade out"]]
	    ]
	};

========================================
   Chapter 3: Scene tree
========================================

The scene tree is a nested dictionary that tells the game how different scenes are connected.
Without the interaction registry, the structure is of the tree graph. The format of the scene key is as follow:
	"<node_type>:<node_name>:<selection_text>:<bg_image.png>; <interaction>(optional)"

Here is an example of a scene tree:

	const WORLD_MAP = {
	    "scene:open world:Open World:icon.png; fn_interaction:intro_logic": {
	        "scene:town:üè∞ Town:icon.png": townData,
	        "scene:forest clearing:ü™µ Forest clearing:icon.png": {
	            "return:return:üîô Exit:icon.png": {},
	            "harvest:cut trees:ü™ì Cut tree:icon.png":
	            [1000, "Chopping wood...", { "Oak log": 1.0, "Branch": 0.5 }],
	        },
	        "scene:mystical woods:üå≤ Mystic woods:woods.png; fn_interaction:woods_intro": woodsData,
	        "scene:mining quarry:ü™® Mining quarry:quarry_dark.png": quarryData,
	        "scene:dark castle:üè∞ Dark Castle:castle_dark.png": darkCastleData,
	    },
	};

In this example, the topmost node is "open world", which is connected to "town", "forest clearing", "mystical woods", "mining quarry", and "dark castle". The value for each of the entry is yet another scene tree.

For each node, one can choose amongst the 6 types:
	1) scene
		If the value is another scene tree, this will send the player to that scene.
		If the value is null, it will do nothing.
	2) return
		Go to the previous node.
	3) harvest
		Trigger a harvest action (mining, tree chopping, foraging, etc.)
		The format is
		"harvest:<node_name>:<selection_text>":
	            [<delay_ms>, "<notification_text>", { <item_name>: <drop_chance> }]
	4) craft
		Converting certain items to another.
		The format is
		"harvest:<node_name>:<selection_text>":
					[
						<delay_ms>, "<notification_text>", {
							"input:<item_name1>": <amount1>,
							"input:<item_name2>": <amount2>, ...,
							"output:<item_name3>": <amount3>,
							"output:<item_name4>": <amount4>, ...
						}
					],
		Note that the amount can be fractional, however, it will be rounded down after the crafting is finished. This is for items that can be used more than once to craft multiple items.
		For example,
		[1000, "Smelting ores...", { "input:Oak log": 0.5, "input:Copper ore": 1, "output:Copper ingot": 1 }]
		means we can use 1 oak log to craft 2 ingots, if we have 2 ores. If you only have one ore, the remaning 0.5 log will be rounded down to zero.

	5) fight
		Fight one of many enemies from the pool.
		Similar to <craft>, the format is
		"fight:<node_name>:<selection_text>":
			[<delay_ms>, "<notification_text>", { <enemy_name>: [<weight>:<enemy_object>] }]
		Here, <enemy_name> is a string acting as the key for the dictionary.
		<weight> is any psotive real number. If there are multiple enemies in this dict, the weights are normalized, after which the enemy will be drawn.
		<enemy_object> is the corresponding Enemy object explained in Chapter 1.

	6) dungeon
		A sequence of <fight>. This one is simple a list of either 1) the enemy entry or 2) interaction.

		For example:

	   "dungeon:throne:‚ò†Ô∏è Approach Throne:icon.png; fn_interaction:demon_lord_interaction": [
	        [1000, "Fighting guards...", { "Shadow Knight": [1, demonGuard] }],
	        [1000, "EPIC BATTLE...", { "Demon King": [1, demonKing] }],
	        ["fn_interaction:demon_king_defeated"]
	   ],

	   This scene has 2 enemies: the "Shadow Knight" and the "Demon King". The scene invokes 2 interactions: <demon_lord_interaction> before the fights and <demon_king_defeated> after the Demon King.


========================================
   Chapter 4: Interaction registry
========================================

Finally, the most complicate topic. INTERACTION_REGISTRY acts as a conditional decision tree for game events. It maps an ID to a list of potential rules, evaluates them top-to-bottom, and executes the data of the first matching rule.

Here is the structural breakdown of INTERACTION_REGISTRY with examples for different use cases.

1. The Root Structure
----------------------------------------

The registry is an object where:
	Key: interactionId (string).
	Value: An Array of Rule Objects. The game checks these rules in order. The first one to return true is executed.


	const INTERACTION_REGISTRY = {
		"chest_01": [ 
			{ /* Rule 1: e.g., Chest is already open */ },
			{ /* Rule 2: e.g., Player has key */ },
			{ /* Rule 3: Default locked message */ }
		]
	};


2. The Rule Object
----------------------------------------

Each rule has two main parts: condition and data.

A. Conditions
Conditions determine if this rule runs. It can be the string "default" (always true) or an Array of checks.

Supported Check Types:
	Item Check (type: "item"): Checks player inventory.
	Variable Check (Implicit): Checks global variables.
	Random Check (var: "rand:uniform"): Generates a float (0.0‚Äì1.0) for probability.

Operators (op): ==, !=, >, <, >=, <=, in (checks if value is inside an array).

B. Data
If the condition passes, data defines what happens.
	log_only: Prints text and stops immediately.
	binding: Sets a global "active variable" (useful for UI context).
	dialogue: The ID of the dialogue to play.
	on_finish: Logic to run after the dialogue (or immediately if no dialogue).


3. The on_finish Logic Structures
----------------------------------------

This is where the complex branching happens. The data.on_finish object executes actions based on variables.

	Case A: Linear Actions
		Just runs a list of actions (give item, set state, move player).
			"reward": give item
			"consume": take item
			"log": text notification
			"goto": move player to another scene
			"set_state": change some variables

	Case B: Boolean Logic (if_true / if_false)
		Checks a variable and splits into two paths. Both paths can have dialogue and actions.

	Case C: Simple Value Mapping (if_value)
		Checks a variable against specific values.

	Case D: Complex Switch Case (switch_case)
		The most advanced handler. Checks a variable against specific values.
		Feature: Can trigger new dialogue AND actions.
		Fallback: Supports default or else.


4. Examples
----------------------------------------

Example 1: Simple Sign (Log Only)
Use case: Clicking a background object that requires no logic or complex dialogue.

	"sign_town_entrance": [
	    {
	        condition: "default",
	        data: {
	            log_only: "The sign reads: 'Welcome to Riverwood'."
	        }
	    }
	]

Example 2: A Treasure Chest (Item Logic)
Use case: A chest that checks if it's already opened, checks if you have a key, or tells you it's locked.

	"dungeon_chest": [
	    {
	    	  comment: "Priority 1: Check if already looted (Variable Check)"
	        condition: [{ var: "chest_dungeon_1_open", op: "==", val: true }],
	        data: { log_only: "The chest is empty." }
	    },
	    {
	    	  comment: "Priority 2: Check if player has the key (Item Check)"
	        condition: [{ type: "item", id: "skeleton_key", op: ">=", val: 1 }],
	        data: {
	            dialogue: openChestDialogueData,
	            on_finish: {
	                actions: [
	                    { type: "consume", item: "skeleton_key", count: 1 }, // Remove key
	                    { type: "set_state", key: "chest_dungeon_1_open", val: true }, // Mark open
	                    { type: "reward", item: "gold_coin", count: 50 }, // Give reward
	                    { type: "log", text: "You used the key and found 50 gold!" }
	                ]
	            }
	        }
	    },
	    {
	    	  comment: "Priority 3: Default (Locked)"
	        condition: "default",
	        data: { log_only: "It's locked. You need a Skeleton Key." }
	    }
	]

Example 3: Random Encounter (RNG Logic)
Use case: 30% chance to find an item, 70% nothing happens.

	"search_bush": [
	    {
	    	  comment: "30% Chance (Random value < 0.3)"
	        condition: [{ var: "rand:uniform", op: "<", val: 0.3 }],
	        data: {
	            on_finish: {
	                actions: [
	                    { type: "reward", item: "healing_herb", count: 1 },
	                    { type: "log", text: "You found a medicinal herb!" }
	                ]
	            }
	        }
	    },
	    {
	    	  comment: "Remaining 70%"
	        condition: "default",
	        data: { log_only: "You search the bush but find nothing." }
	    }
	]

Example 4: Complex NPC Interaction (Switch Case)
Use case: An NPC reacts differently based on your reputation ('hero', 'villain', or 'neutral'). This utilizes the new switch_case logic to branch into different dialogues.

	"npc_guard": [
	    {
	        condition: "default",
	        data: {
	            dialogue: guardGreetingData, // Initial "Halt!"
	            on_finish: {
	                check_var: "player_reputation", // Variable to switch on
	                switch_case: {
	                    "hero": {
	                        dialogue: guardSaluteData, // Dialogue for hero
	                        actions: [{ type: "log", text: "The guard salutes you." }]
	                    },
	                    "villain": {
	                        dialogue: guardAttackData, // Dialogue for villain
	                        actions: [{ type: "set_state", key: "combat_mode", val: true }]
	                    },
	                    "default": {
	                        dialogue: GuardShrugData, // Fallback dialogue
	                        actions: [{ type: "log", text: "The guard ignores you." }]
	                    }
	                }
	            }
	        }
	    }
	]

Example 5: Navigation (Goto)
Use case: Moving to another map node/scene.

	"door_to_basement": [
	    {
	        condition: "default",
	        data: {
	            dialogue: "enter_door_sound",
	            on_finish: {
	                actions: [
	                    { type: "goto", target: "basement_node_id" } 
	                ]
	            }
	        }
	    }
	]

Example 6: The Gatekeeper's Riddle
Use Case: An ancient statue asks a question. You must choose the correct element ("Fire") to proceed.

"ancient_statue_riddle": [
    {
        condition: "default",
        data: {
            // 1. BINDING: Tell the engine to store the dialogue choice in "riddle_answer"
            binding: "riddle_answer",

            // 2. DIALOGUE: This ID implies a conversation with choices
            // (e.g., Choice A: "Water", Choice B: "Fire", Choice C: "Earth")
            dialogue: statueRiddleDialogueData, 

            // 3. ON FINISH: Check the variable we just bound
            on_finish: {
                check_var: "riddle_answer", 

                // React based on what the player clicked
                switch_case: {
                    "Fire": {
                        dialogue: statueSuccessData,
                        actions: [
                            { type: "log", text: "The statue eyes glow red. The door opens." },
                            { type: "set_state", key: "temple_door_open", val: true }
                        ]
                    },
                    "Water": {
                        dialogue: statueFailWetData,
                        actions: [
                            { type: "log", text: "Water sprays from the statue!" },
                        ]
                    },
                    "default": {
                        dialogue: statueConfusedData,
                        actions: [{ type: "log", text: "The statue remains silent." }]
                    }
                }
            }
        }
    }
]







