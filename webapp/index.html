<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical RPG UI - Stat Breakdown</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #2a2a2a;
            --accent: #ffcc00;
            --hp-color: #ff4d4d;
            --enemy-hp-color: #ff4757;
            --exp-color: #ffd700;
            --text-main: #eee;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-mono: 'Courier New', monospace;
        }

        body {
            background-color: #000;
            color: var(--text-main);
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-device {
            width: 100%;
            max-width: 400px;
            height: 100%;
            max-height: 800px;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
        }

        /* --- TOP PANEL (Graphics & Logs) --- */
        #visual-panel {
            flex: 6; 
            position: relative;
            background-color: #000;
            overflow: hidden;
            border-bottom: 4px solid var(--panel-bg);
        }

        #scene-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.7; 
            transition: opacity 0.3s;
        }
        
        #scene-image:after {
            content: 'Image not found';
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #333 0%, #000 100%);
            position: absolute;
            top: 0; left: 0;
            z-index: -1;
        }

        /* --- HUD OVERLAY --- */
        #hud-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            z-index: 20;
            font-family: var(--font-mono);
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }

        #enemy-hud {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            z-index: 20;
            font-family: var(--font-mono);
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #enemy-hud.visible { opacity: 1; }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .hud-text {
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 2px black;
        }

        #menu-toggle-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: #eee;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: background 0.2s;
        }
        #menu-toggle-btn:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .bar-container {
            flex-grow: 1;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(0,0,0,0.5);
            margin-left: 10px;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease-out;
        }

        .hp-fill { background-color: var(--hp-color); }
        .exp-fill { background-color: var(--exp-color); }
        .enemy-fill { background-color: var(--enemy-hp-color); }

        #location-pill {
            position: absolute;
            top: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid #555;
            z-index: 10;
            opacity: 0.8;
        }

        #toast-container {
            position: absolute;
            bottom: 60px;
            left: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: flex-start;
            pointer-events: none;
            gap: 5px;
            height: 30%;
            overflow: hidden;
        }

        .toast {
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            border-left: 3px solid var(--accent);
            font-size: 12px;
            font-family: var(--font-mono);
            animation: fadeSequence 2.5s forwards;
            max-width: 90%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes fadeSequence {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }

        /* --- BOTTOM PANEL (Controls) --- */
        #control-panel {
            flex: 4;
            background-color: var(--panel-bg);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #menu-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .menu-item {
            padding: 12px 15px;
            background-color: #383838;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
        }

        .menu-item.active {
            background-color: #eee;
            color: #000;
            border-color: var(--accent);
            transform: scale(1.02);
            font-weight: bold;
        }

        .menu-item-tag {
            font-size: 10px;
            background: #ff4d4d;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .insufficient {
            font-size: 11px;
            color: #ff4d4d;
            margin-left: 10px;
            font-style: italic;
        }
        
        /* INVENTORY STYLES */
        .inv-btn {
            background: #444;
            border: 1px solid #666;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            cursor: pointer;
            margin-left: 8px;
            border-radius: 3px;
        }
        .inv-btn:hover { background: var(--accent); color: black; }
        .equip-slot {
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 4px;
            margin-bottom: 5px;
            display:flex; justify-content:space-between; align-items:center;
            border: 1px solid transparent; 
        }
        
        /* Focused row in inventory menu */
        .menu-focus-row {
            border-color: var(--accent) !important;
            background-color: rgba(255, 255, 255, 0.1) !important;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 2px; }
    </style>
</head>
<body>

<div id="game-device">
    <div id="visual-panel">
        <div id="hud-overlay">
            <div class="hud-row">
                <span id="player-name" class="hud-text">Player Lv.1</span>
                <div id="menu-toggle-btn">ðŸŽ’ Bag (C)</div>
            </div>
            <div class="hud-row">
                <span style="font-size:10px; width:20px;">HP</span>
                <div class="bar-container">
                    <div id="hud-hp-bar" class="bar-fill hp-fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="hud-row">
                <span style="font-size:10px; width:20px;">EXP</span>
                <div class="bar-container">
                    <div id="hud-exp-bar" class="bar-fill exp-fill" style="width: 0%;"></div>
                </div>
            </div>
        </div>

        <div id="enemy-hud">
            <div class="hud-row">
                <span id="enemy-name" class="hud-text">Enemy Name</span>
                <span id="enemy-stats" style="font-size:12px; color:#ccc;"></span>
            </div>
            <div class="hud-row" style="margin-top:5px;">
                <div class="bar-container" style="margin-left:0;">
                    <div id="enemy-hp-bar" class="bar-fill enemy-fill" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <div id="location-pill">Loading...</div>
        <img id="scene-image" src="" alt="Scene" onerror="this.style.opacity='0.2'">
        <div id="toast-container"></div>
    </div>

    <div id="control-panel">
        <div id="menu-list"></div>
    </div>
</div>

<script>
    // --- 1. CORE DEFINITIONS ---

    class Skills {
        constructor(attack, defense, healing, luck) {
            this.attack = attack;
            this.defense = defense;
            this.healing = healing;
            this.luck = luck;
        }
        add(other) {
            return new Skills(
                this.attack + other.attack,
                this.defense + other.defense,
                this.healing + other.healing,
                this.luck + other.luck
            );
        }
    }

    class Item {
        constructor(name, is_weapon, is_armor_body, is_armor_leggings, amount, bonus_hp, bonus_skills) {
            this.name = name;
            this.is_weapon = is_weapon;
            this.is_armor_body = is_armor_body;
            this.is_armor_leggings = is_armor_leggings;
            this.amount = amount;
            this.bonus_hp = bonus_hp;
            this.bonus_skills = bonus_skills || new Skills(0,0,0,0);
        }
    }

    const ITEM_DEFINITIONS = {
        "Copper dagger": { 
            is_weapon: true, is_armor_body: false, is_armor_leggings: false, 
            bonus_hp: 0, bonus_skills: new Skills(2, 0, 0, 1) 
        },
        "Leather vest": { 
            is_weapon: false, is_armor_body: true, is_armor_leggings: false, 
            bonus_hp: 5, bonus_skills: new Skills(0, 2, 0, 0) 
        },
        "Leather pants": { 
            is_weapon: false, is_armor_body: false, is_armor_leggings: true, 
            bonus_hp: 2, bonus_skills: new Skills(0, 1, 0, 1) 
        }
    };

    class Enemy {
        constructor(name, hp, loots, skills) {
            this.name = name;
            this.hp = hp;
            this.maxHp = hp; 
            this.loots = loots;
            this.skills = skills;
        }
    }

    // --- 2. DATA ---

    const copperSpider = new Enemy("Copper spider", 10, { "Copper spider legs": 1 }, new Skills(4,2,0,1));

    const worldMap = {
        "scene:open_world:Open World:world_map.png": {
            "scene:town:Town:town_square.png": {
                "scene:blacksmith:Blacksmith:icon_anvil.png": {
                    "craft:smelt_ore:Smelt ore:icon_anvil.png": [1000, "Smelting ores...", {
                        "input:Oak log": 0.5, "input:Copper ore": 1, "output:Copper ingot": 1 }],
                    "craft:craft_dagger:Copper dagger:icon_hammer.png": [1000, "Crafting...", {
                        "input:Copper ingot": 1, "output:Copper dagger": 1 }],
                    "return:return:Exit shop:icon_exit.png": {},
                },
                "return:return:Exit town:icon_exit.png": {},
            },
            "scene:logging_camp:Logging camp:forest_clearing.png": {
                "harvest:cut_trees:Cut trees:icon_axe.png": [1000, "Chopping wood...", { "Oak log": 2, "Branch": 1 }],
                "return:return:Exit logging camp:icon_exit.png": {},
            },
            "scene:mining_quarry:Mining quarry:quarry_dark.png": {
                "harvest:mine_ores:Mine ores:icon_pickaxe.png": [1000, "Mining rocks...", { "Copper ore": 9, "Garnet": 1 }],
                "fight:spider:Look for trouble:icon_sword.png": [1000, "Fighting...", { "Copper spider": [1, copperSpider] }],
                "return:return:Exit mining quarry:icon_exit.png": {},
            },
        },
    };

    // --- 3. UTILITIES ---

    function dictDraw(dct) {
        let norm = 0;
        let entries = [];
        for (let key in dct) {
            let weight = dct[key];
            let item = key;
            if (Array.isArray(weight)) {
                item = weight[1]; 
                weight = weight[0];
            }
            if (weight < 0) return null;
            norm += weight;
            entries.push({ item, weight });
        }
        let r = Math.random() * norm;
        let accWgh = 0;
        for (let entry of entries) {
            accWgh += entry.weight;
            if (r < accWgh) return entry.item;
        }
        return null;
    }

    // --- 4. ENGINE CLASSES ---

    class CharacterMenu {
        constructor() {
            this.name = "Player";
            this.exp = 0;
            this.inventory = {};
            this.equipment = { weapon: null, body: null, leggings: null };
            this.active = false; 
            this.hp = 10;
            this.skills = new Skills(4,2,1,1);
            
            // New Nav State
            this.menuCursor = 0; 
            this.interactables = []; // To map indices to items/slots
        }

        createItem(name, amount) {
            let def = ITEM_DEFINITIONS[name] || {};
            return new Item(
                name, 
                def.is_weapon || false, 
                def.is_armor_body || false, 
                def.is_armor_leggings || false, 
                amount, 
                def.bonus_hp || 0, 
                def.bonus_skills || new Skills(0,0,0,0)
            );
        }

        addItem(name, amount = 1) {
            if (typeof name === 'object' && name.name) name = name.name;
            if (!this.inventory[name]) {
                this.inventory[name] = this.createItem(name, 0);
            }
            this.inventory[name].amount += amount;
        }
        
        getItemCount(name) {
            return this.inventory[name] ? this.inventory[name].amount : 0;
        }

        equipItem(itemName) {
            if (!this.inventory[itemName] || this.inventory[itemName].amount <= 0) return;
            let item = this.inventory[itemName];
            let slot = null;

            if (item.is_weapon) slot = "weapon";
            else if (item.is_armor_body) slot = "body";
            else if (item.is_armor_leggings) slot = "leggings";

            if (slot) {
                this.unequipItem(slot);
                item.amount--;
                if (item.amount === 0) delete this.inventory[itemName];
                this.equipment[slot] = this.createItem(itemName, 1);
                Game.log(`Equipped: ${itemName}`);
                Game.render();
            }
        }

        unequipItem(slot) {
            if (this.equipment[slot]) {
                let item = this.equipment[slot];
                this.addItem(item.name, 1);
                this.equipment[slot] = null;
                Game.log(`Unequipped: ${item.name}`);
                Game.render();
            }
        }

        getCombatSkills() {
            let total = new Skills(this.skills.attack, this.skills.defense, this.skills.healing, this.skills.luck);
            for (let slot in this.equipment) {
                if (this.equipment[slot]) {
                    total = total.add(this.equipment[slot].bonus_skills);
                }
            }
            return total;
        }

        getLevel() { return Math.floor(Math.sqrt(0.1 * this.exp)); }
        getMaxExp() { return 10 * Math.pow(this.getLevel() + 1, 2); }
        getMaxHP() { 
            let base = 10 + (this.getLevel() * 5);
            let bonus = 0;
            for(let slot in this.equipment) {
                if(this.equipment[slot]) bonus += this.equipment[slot].bonus_hp;
            }
            return base + bonus;
        }

        // --- KEYBOARD NAVIGATION METHODS ---

        moveCursor(offset) {
            if (this.interactables.length === 0) return;
            this.menuCursor += offset;
            if (this.menuCursor < 0) this.menuCursor = this.interactables.length - 1;
            if (this.menuCursor >= this.interactables.length) this.menuCursor = 0;
            Game.render();
        }

        selectOption() {
            if (this.interactables.length === 0) return;
            const target = this.interactables[this.menuCursor];
            
            if (target.type === 'slot') {
                this.unequipItem(target.id);
            } else if (target.type === 'item') {
                this.equipItem(target.id);
            }
        }

        getDisplayHTML() {
            this.interactables = []; // Reset list
            let counter = 0;

            let invHTML = "";
            let keys = Object.keys(this.inventory);

            // 1. Render Equipment Slots
            let equipHTML = "";
            ['weapon', 'body', 'leggings'].forEach(slot => {
                let item = this.equipment[slot];
                
                // Track this slot for navigation
                this.interactables.push({ type: 'slot', id: slot });
                let isSelected = (counter === this.menuCursor);
                counter++;

                let slotClass = "equip-slot";
                if (isSelected) slotClass += " menu-focus-row";

                let content = item ? `${item.name} <span class="inv-btn" onclick="Game.player.unequipItem('${slot}')">Unequip</span>` 
                                   : `<span style="color:#666">Empty ${slot}</span>`;
                
                equipHTML += `<div class="${slotClass}"><span>${content}</span></div>`;
            });

            // 2. Render Inventory List
            if (keys.length > 0) {
                keys.forEach(key => {
                    let item = this.inventory[key];
                    let displayCount = Number.isInteger(item.amount) ? item.amount : item.amount.toFixed(1);
                    
                    let canEquip = (item.is_weapon || item.is_armor_body || item.is_armor_leggings);
                    
                    // Track for navigation
                    this.interactables.push({ type: canEquip ? 'item' : 'none', id: key });
                    let isSelected = (counter === this.menuCursor);
                    counter++;

                    let rowStyle = "display:flex; justify-content:space-between; margin-bottom:4px; padding:2px 4px; border-radius:4px; border:1px solid transparent;";
                    let className = isSelected ? "menu-focus-row" : "";
                    
                    if (isSelected) rowStyle += " border-color: var(--accent); background: rgba(255,255,255,0.1);";

                    let actionBtn = "";
                    if (canEquip) {
                        actionBtn = `<span class="inv-btn" onclick="Game.player.equipItem('${key}')">Equip</span>`;
                    }

                    invHTML += `<div class="${className}" style="${rowStyle}">
                        <span>- ${item.name} x${displayCount}</span>
                        ${actionBtn}
                    </div>`;
                });
            } else {
                invHTML = "<div style='color:#666; font-style:italic'>(Bag is empty)</div>";
            }

            let combatSkills = this.getCombatSkills();

            // --- FORMAT STATS (Base + Bonus) ---
            const formatStat = (base, total) => {
                let bonus = total - base;
                return bonus > 0 ? `${base}<span style="color:#4f4">+${bonus}</span>` : `${base}`;
            };

            let atkDisplay = formatStat(this.skills.attack, combatSkills.attack);
            let defDisplay = formatStat(this.skills.defense, combatSkills.defense);
            let healDisplay = formatStat(this.skills.healing, combatSkills.healing);
            let lckDisplay = formatStat(this.skills.luck, combatSkills.luck);

            return `
            <div style="font-family:'Courier New'; line-height:1.4; font-size:13px;">
                <div style="border-bottom:1px solid #555; margin-bottom:10px; padding-bottom:5px; text-align:center;">
                    <strong>CHARACTER MENU</strong>
                </div>
                
                <div style="margin-bottom:10px;">
                    <div style="color:var(--accent); font-weight:bold;">ATTRIBUTES</div>
                    <div>ATK: ${atkDisplay} | DEF: ${defDisplay}</div>
                    <div>HEAL: ${healDisplay} | LCK: ${lckDisplay}</div>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="color:var(--accent); font-weight:bold; margin-bottom:5px;">EQUIPMENT (Enter to Unequip)</div>
                    ${equipHTML}
                </div>

                <div>
                    <div style="color:var(--accent); font-weight:bold; margin-bottom:5px;">INVENTORY (Enter to Equip)</div>
                    <div id="inv-scroll-container" style="max-height:150px; overflow-y:auto; padding-right:5px;">
                        ${invHTML}
                    </div>
                </div>
                
                <br>
                <div style="text-align:center; color:#888; border-top:1px solid #555; padding-top:5px;">
                    [Close: C/Bag]
                </div>
            </div>`;
        }
    }

    // --- 5. MAIN GAME ENGINE ---

    const Game = {
        player: new CharacterMenu(),
        
        currentNode: null,
        currentTitle: "",
        currentImage: "",
        pathStack: [],
        cursor: 0,
        
        activeInterval: null,
        currentActionName: "", 
        inCombat: false, 

        init: function() {
            this.player.hp = this.player.getMaxHP();
            const startKey = Object.keys(worldMap)[0]; 
            this.enterScene(startKey, worldMap[startKey]);
            this.setupInput();
            this.updatePlayerHUD(); 
            this.startPassiveRegen();

            document.getElementById('menu-toggle-btn').onclick = () => {
                this.toggleCharacterMenu();
            };
        },

        toggleCharacterMenu: function() {
            this.player.active = !this.player.active;
            // Reset cursor when opening for better UX
            if(this.player.active) this.player.menuCursor = 0; 
            this.render();
        },

        startPassiveRegen: function() {
            setInterval(() => {
                if (this.inCombat) return;
                const maxHp = this.player.getMaxHP();
                if (this.player.hp <= 0 || this.player.hp >= maxHp) return;
                this.player.hp += this.player.skills.healing;
                if (this.player.hp > maxHp) this.player.hp = maxHp;
                this.updatePlayerHUD();
            }, 2000); 
        },

        updatePlayerHUD: function() {
            const lvl = this.player.getLevel();
            document.getElementById('player-name').textContent = `${this.player.name} Lv.${lvl}`;
            const maxHp = this.player.getMaxHP();
            const hpPct = Math.max(0, Math.min(100, (this.player.hp / maxHp) * 100));
            document.getElementById('hud-hp-bar').style.width = `${hpPct}%`;
            const maxExp = this.player.getMaxExp();
            const expPct = Math.max(0, Math.min(100, (this.player.exp / maxExp) * 100));
            document.getElementById('hud-exp-bar').style.width = `${expPct}%`;
        },

        showEnemyHUD: function(name, currentHp, maxHp) {
            const hud = document.getElementById('enemy-hud');
            hud.classList.add('visible');
            document.getElementById('enemy-name').textContent = name;
            this.updateEnemyHUD(currentHp, maxHp);
        },

        updateEnemyHUD: function(currentHp, maxHp) {
            const hpPct = Math.max(0, Math.min(100, (currentHp / maxHp) * 100));
            document.getElementById('enemy-hp-bar').style.width = `${hpPct}%`;
            document.getElementById('enemy-stats').textContent = `${Math.ceil(currentHp)}/${maxHp} HP`;
        },

        hideEnemyHUD: function() {
            const hud = document.getElementById('enemy-hud');
            hud.classList.remove('visible');
        },

        render: function() {
            document.getElementById('location-pill').textContent = this.currentTitle;
            document.getElementById('scene-image').src = "images/bg/"+this.currentImage;
            
            this.updatePlayerHUD();

            const menuContainer = document.getElementById('menu-list');
            menuContainer.innerHTML = '';

            // --- MENU RENDER LOGIC ---
            if (this.player.active) {
                menuContainer.innerHTML = this.player.getDisplayHTML();
                
                // AUTO SCROLL LOGIC
                const activeRow = document.querySelector('.menu-focus-row');
                if (activeRow) {
                    activeRow.scrollIntoView({ block: 'nearest' });
                }
                return;
            }

            const options = Object.keys(this.currentNode);
            
            if(options.length === 0) {
                menuContainer.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">Nothing here...</div>';
                return;
            }

            options.forEach((key, index) => {
                const info = this.parseKey(key);
                const el = document.createElement('div');
                
                el.className = 'menu-item';
                if (index === this.cursor) el.classList.add('active');

                el.onmouseenter = () => {
                    this.cursor = index;
                    Array.from(menuContainer.children).forEach(child => child.classList.remove('active'));
                    el.classList.add('active');
                };

                let content = `<span>${info.name}</span>`;
                
                if (info.role === 'craft') {
                    const recipe = this.currentNode[key][2];
                    let canAfford = true;
                    for (let rKey in recipe) {
                        if (rKey.startsWith('input:')) {
                            let item = rKey.split(':')[1];
                            let cost = recipe[rKey];
                            if (this.player.getItemCount(item) < cost) {
                                canAfford = false;
                            }
                        }
                    }
                    if (!canAfford) {
                        content += `<span class="insufficient">(insufficient ingredients)</span>`;
                    }
                }

                if (this.activeInterval && this.currentActionName === key) {
                    content += `<span class="menu-item-tag">STOP</span>`;
                }
                el.innerHTML = content;
                
                el.onclick = () => {
                    this.cursor = index;
                    this.executeOption();
                    this.render();
                };

                menuContainer.appendChild(el);
            });
            
            const activeEl = menuContainer.children[this.cursor];
            if(activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        },

        log: function(msg) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = msg;
            container.appendChild(toast);
            setTimeout(() => {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
            }, 2500);
        },

        parseKey: function(keyString) {
            const parts = keyString.split(':');
            return {
                role: parts[0],
                id: parts[1],
                name: parts[2] || parts[1],
                image: parts[3] || "placeholder.png"
            };
        },

        enterScene: function(keyString, nodeObj) {
            const info = this.parseKey(keyString);
            if (this.currentNode) {
                this.pathStack.push({
                    node: this.currentNode,
                    title: this.currentTitle,
                    image: this.currentImage,
                    cursor: this.cursor
                });
            }
            this.currentNode = nodeObj;
            this.currentTitle = info.name;
            this.currentImage = info.image;
            this.cursor = 0;
            this.stopAction();
            this.render();
        },

        returnScene: function() {
            if (this.pathStack.length === 0) return;
            const previous = this.pathStack.pop();
            this.currentNode = previous.node;
            this.currentTitle = previous.title;
            this.currentImage = previous.image;
            this.cursor = previous.cursor;
            this.stopAction();
            this.render();
        },

        stopAction: function() {
            if (this.activeInterval) {
                clearInterval(this.activeInterval);
                this.activeInterval = null;
                this.currentActionName = "";
                this.inCombat = false; 
                this.hideEnemyHUD(); 

                // --- CRAFTING CLEANUP ---
                // Round down all ingredients when action stops.
                for (let key in this.player.inventory) {
                    this.player.inventory[key].amount = Math.floor(this.player.inventory[key].amount);
                    if (this.player.inventory[key].amount <= 0) delete this.player.inventory[key];
                }

                this.render();
            }
        },

        executeOption: function() {
            const keys = Object.keys(this.currentNode);
            if (keys.length === 0) return;

            const selectedKey = keys[this.cursor];
            const selectedValue = this.currentNode[selectedKey];
            const info = this.parseKey(selectedKey);

            if (this.activeInterval && this.currentActionName === selectedKey) {
                this.stopAction();
                return;
            }

            switch (info.role) {
                case "scene":
                    this.enterScene(selectedKey, selectedValue);
                    break;
                case "return":
                    this.returnScene();
                    break;
                case "harvest":
                    this.stopAction();
                    this.currentActionName = selectedKey;
                    this.startHarvestLoop(selectedValue[0], selectedValue[1], selectedValue[2]);
                    this.render();
                    break;
                case "fight":
                    this.stopAction();
                    this.currentActionName = selectedKey;
                    this.startFightLoop(selectedValue[0], selectedValue[1], selectedValue[2]);
                    this.render();
                    break;
                case "craft":
                    this.stopAction();
                    this.currentActionName = selectedKey;
                    this.startCraftLoop(selectedValue[0], selectedValue[1], selectedValue[2]);
                    this.render();
                    break;
                default:
                    this.log(`Unknown role: ${info.role}`);
            }
        },

        startCraftLoop: function(interval, notif, recipe) {
            this.log(notif);
            this.activeInterval = setInterval(() => {
                let canAfford = true;
                for (let key in recipe) {
                    if (key.startsWith("input:")) {
                        let item = key.split(":")[1];
                        let cost = recipe[key];
                        if (this.player.getItemCount(item) < cost) {
                            canAfford = false;
                        }
                    }
                }
                if (!canAfford) {
                    this.log("Stopped: Insufficient ingredients.");
                    this.stopAction(); // This will trigger the rounding cleanup
                    return;
                }
                for (let key in recipe) {
                    if (key.startsWith("input:")) {
                        let item = key.split(":")[1];
                        let cost = recipe[key];
                        this.player.inventory[item].amount -= cost;
                    }
                }
                let outputStr = "";
                for (let key in recipe) {
                    if (key.startsWith("output:")) {
                        let item = key.split(":")[1];
                        let amount = recipe[key];
                        this.player.addItem(item, amount);
                        outputStr += `${amount} ${item} `;
                    }
                }
                this.log(`Crafted: ${outputStr}`);
                this.render(); 
            }, interval);
        },

        startHarvestLoop: function(interval, notif, itemDict) {
            this.log(notif);
            this.activeInterval = setInterval(() => {
                const item = dictDraw(itemDict);
                if (item) {
                    this.player.addItem(item);
                    this.log(`+1 ${item}`);
                    this.updatePlayerHUD(); 
                }
            }, interval);
        },

        startFightLoop: function(interval, notif, enemyDict) {
            this.inCombat = true; 
            let enemyTemplate = dictDraw(enemyDict); 
            let enemy = new Enemy(enemyTemplate.name, enemyTemplate.hp, enemyTemplate.loots, enemyTemplate.skills);
            let turn = 0; 
            let enemy_hp = enemy.hp;
            
            let currentSkills = this.player.getCombatSkills();

            this.showEnemyHUD(enemy.name, enemy_hp, enemy.maxHp);
            this.log(`Encounter: ${enemy.name}!`);

            this.activeInterval = setInterval(() => {
                this.updateEnemyHUD(enemy_hp, enemy.maxHp);
                if (enemy_hp <= 0) {
                    let loot = dictDraw(enemy.loots);
                    this.player.addItem(loot);
                    this.log(`Victory! Found: ${loot}`);
                    this.stopAction();
                    return;
                }
                if (this.player.hp <= 0) {
                    this.log(`Defeated! Retreated.`);
                    this.stopAction();
                    this.player.hp = 1; 
                    this.updatePlayerHUD();
                    return;
                }
                if (turn === 1) {
                    const dmg = Math.max(0, enemy.skills.attack - currentSkills.defense);
                    if (Math.random() < 1-Math.exp(-enemy.skills.luck)) {
                        this.player.hp -= dmg;
                        this.log(`Enemy hits for ${dmg} dmg!`);
                    } else {
                        this.log(`Enemy missed!`);
                    }
                    turn = 0;
                } else {
                    const dmg = Math.max(0, currentSkills.attack - enemy.skills.defense);
                    if (Math.random() < 1-Math.exp(-currentSkills.luck)) {
                        enemy_hp -= dmg;
                        this.player.exp += 1;
                        this.log(`Hit ${enemy.name} for ${dmg} dmg!`);
                    } else {
                        this.log(`You missed!`);
                    }
                    turn = 1;
                }
                this.updatePlayerHUD(); 
            }, interval);
        },

        setupInput: function() {
            document.addEventListener('keydown', (e) => {
                // --- ARROW KEYS ---
                if (e.key === "ArrowUp") {
                    if (this.player.active) {
                        this.player.moveCursor(-1);
                    } else {
                        const max = Object.keys(this.currentNode).length;
                        if(max > 0) {
                            this.cursor = (this.cursor - 1 + max) % max;
                            this.render();
                        }
                    }
                } else if (e.key === "ArrowDown") {
                    if (this.player.active) {
                        this.player.moveCursor(1);
                    } else {
                        const max = Object.keys(this.currentNode).length;
                        if(max > 0) {
                            this.cursor = (this.cursor + 1) % max;
                            this.render();
                        }
                    }
                } 
                // --- ENTER KEY ---
                else if (e.key === "Enter") {
                    if (this.player.active) {
                        this.player.selectOption();
                    } else {
                        this.executeOption();
                    }
                } 
                // --- MENU TOGGLES ---
                else if (e.key.toLowerCase() === "c") {
                    this.toggleCharacterMenu();
                } 
                else if (e.key === "Escape") {
                    if (this.player.active) {
                        this.toggleCharacterMenu();
                    } else {
                        this.stopAction();
                    }
                }
            });
        }
    };

    Game.init();

</script>

</body>
</html>